// game book

start: metadata sections

_nl: NEWLINE

metadata: metadata_entry+
?metadata_entry: metadata_tag ":" metadata_value? _nl
?metadata_tag: IDENTIFIER
?metadata_value: REMAINING_LINE

sections: section statement+
section: "[" SECTION_NAME "]" _nl

SECTION_NAME: /[^]]+/i

direction_statement: "direction" short_format_string direction_section direction_facing _nl

direction_section: STRING
short_format_string: STRING

direction_facing: ("facing" STRING)?
    | "facing" "(" expression ")" -> facing_expr

option_statement: "option" STRING compound_statement

// run once, first time run, further runs are a noop
once_statement: "once" compound_statement | "once" compound_statement once_else compound_statement
once_else: "else"

// partial grammar taken from https://raw.githubusercontent.com/igordejanovic/parglare/master/examples/c/c2.pg

?statement: section
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | comment
    | direction_statement
    | once_statement
    | assignment_statement
    | option_statement
    | go_statement
    | empty_statement
    | scope_statement

scope_statement: (WORLD | SECTION | LOCAL | EXTERN) IDENTIFIER _nl


WORLD: "world"
SECTION: "section"
LOCAL: "local"
EXTERN: "extern"


go_statement: "go" next_section _nl
next_section: STRING

?compound_statement: "{" "}" | "{"  block_item_list "}"
?block_item_list: block_item | block_item_list block_item
?block_item.1: declaration | statement

type_name: specifier_qualifier_list abstract_declarator
    | specifier_qualifier_list

abstract_declarator: pointer direct_abstract_declarator
    | pointer
    | direct_abstract_declarator

specifier_qualifier_list: type_specifier specifier_qualifier_list
    | type_specifier
    | type_qualifier specifier_qualifier_list
    | type_qualifier
    
direct_abstract_declarator: "(" abstract_declarator ")"
    | "[" "]"
    | "[" "*" "]"
    | "[" STATIC type_qualifier_list assignment_expression "]"
    | "[" STATIC assignment_expression "]"
    | "[" type_qualifier_list STATIC assignment_expression "]"
    | "[" type_qualifier_list assignment_expression "]"
    | "[" type_qualifier_list "]"
    | "[" assignment_expression "]"
    | direct_abstract_declarator "[" "]"
    | direct_abstract_declarator "[" "*" "]"
    | direct_abstract_declarator "[" STATIC type_qualifier_list assignment_expression "]"
    | direct_abstract_declarator "[" STATIC assignment_expression "]"
    | direct_abstract_declarator "[" type_qualifier_list assignment_expression "]"
    | direct_abstract_declarator "[" type_qualifier_list STATIC assignment_expression "]"
    | direct_abstract_declarator "[" type_qualifier_list "]"
    | direct_abstract_declarator "[" assignment_expression "]"
    | "(" ")"
    | "(" parameter_type_list ")"
    | direct_abstract_declarator "(" ")"
    | direct_abstract_declarator "(" parameter_type_list ")"

pointer: "*" type_qualifier_list pointer
    | "*" type_qualifier_list
    | "*" pointer
    | "*"

type_qualifier_list: type_qualifier
    | type_qualifier_list type_qualifier
    
parameter_type_list: parameter_list "," ELLIPSIS
    | parameter_list


parameter_list: parameter_declaration
    | parameter_list "," parameter_declaration


parameter_declaration: declaration_specifiers declarator
    | declaration_specifiers abstract_declarator
    | declaration_specifiers


identifier_list: IDENTIFIER
    | identifier_list "," IDENTIFIER


type_specifier: WORLD | SECTION | LOCAL | EXTERN | enum_specifier

type_qualifier: CONST

?expression_statement: expression _nl

empty_statement: _nl+

selection_statement: if_else_statement
    | if_statement
    | switch_statement

if_else_statement: IF "(" expression ")" statement ELSE statement
if_statement: IF "(" expression ")" statement
switch_statement: SWITCH "(" expression ")" statement

iteration_statement: WHILE "(" expression ")" statement
    | DO statement WHILE "(" expression ")" _nl
    | FOR "(" expression_statement expression_statement ")" statement
    | FOR "(" expression_statement expression_statement expression ")" statement
    | FOR "(" declaration expression_statement ")" statement
    | FOR "(" declaration expression_statement expression ")" statement
    
jump_statement: GOTO expression _nl -> goto_statement
    | CONTINUE _nl
    | BREAK _nl
    | RETURN _nl
    | RETURN expression _nl

?cast_expression: unary_expression | dice_roll

dice_roll: unary_expression "@" unary_expression dice_explode
dice_explode: X?
X: "x"

?multiplicative_expression: cast_expression
    | multiplicative_expression "*" cast_expression -> multiply
    | multiplicative_expression "/" cast_expression -> divide
    | multiplicative_expression "%" cast_expression -> modulo
    | multiplicative_expression "//" cast_expression -> int_divide

?additive_expression: multiplicative_expression
    | additive_expression "+" multiplicative_expression -> addition
    | additive_expression "-" multiplicative_expression -> subtraction

?shift_expression: additive_expression

?relational_expression: shift_expression
    | relational_expression LT_OP shift_expression -> is_lt
    | relational_expression GT_OP shift_expression -> is_gt
    | relational_expression LE_OP shift_expression -> is_lte
    | relational_expression GE_OP shift_expression -> is_gte

?equality_expression: relational_expression
    | equality_expression EQ_OP relational_expression -> is_eq
    | equality_expression NE_OP relational_expression -> is_not_eq

?and_expression: equality_expression

?exclusive_or_expression: and_expression

?inclusive_or_expression: exclusive_or_expression

?logical_and_expression: inclusive_or_expression
    | logical_and_expression and_op inclusive_or_expression -> logical_and

and_op: AND_OP

?logical_or_expression: logical_and_expression
    | logical_or_expression or_op logical_and_expression -> logical_or

or_op: OR_OP

//ternary

conditional_expression: logical_or_expression | ternary_expression

ternary_expression: logical_or_expression "?" expression ":" conditional_expression

assignment_expression: conditional_expression

    //| unary_expression assignment_operator assignment_expression

assignment_statement: unary_expression assignment_operator assignment_expression
assignment_operator: ASSIGN
    | MUL_ASSIGN
    | DIV_ASSIGN
    | MOD_ASSIGN
    | ADD_ASSIGN
    | SUB_ASSIGN

?expression: assignment_expression
    | expression "," assignment_expression
    // | "[" expression "]"

constant_expression: conditional_expression    // with constraints

declaration: declaration_specifiers _nl

declaration_specifiers: type_specifier IDENTIFIER
    | type_qualifier declaration_specifiers

declarator: pointer direct_declarator
    | direct_declarator
    
enum_specifier: ENUM "{" enumerator_list "}"
    | ENUM "{" enumerator_list "," "}"
    | ENUM IDENTIFIER "{" enumerator_list "}"
    | ENUM IDENTIFIER "{" enumerator_list "," "}"
    | ENUM IDENTIFIER
    
?unary_expression: postfix_expression
    | unary_operator cast_expression -> unary_cast

unary_operator: "+" -> expression_positive
    | "-" -> expression_negate
    | "!" -> logical_not

direct_declarator: IDENTIFIER
    | "(" declarator ")"
    | direct_declarator "[" "]"
    | direct_declarator "(" parameter_type_list ")"
    | direct_declarator "(" ")"
    | direct_declarator "(" identifier_list ")"

enumerator_list: enumerator
    | enumerator_list "," enumerator


// identifiers must be flagged as ENUMERATION_CONSTANT
enumerator: enumeration_constant "=" constant_expression
    | enumeration_constant

postfix_expression: primary_expression
    | postfix_array
    | postfix_function_void
    | postfix_function_params
    | postfix_dot

?postfix_dot: postfix_expression DOT IDENTIFIER
postfix_array: postfix_expression lbracket expression rbracket

lbracket: "["
rbracket: "]"

postfix_function_void: postfix_expression param_void
postfix_function_params: postfix_expression param_args

param_void: "(" ")"
param_args: "(" argument_expression_list ")"

?assign_identifier: postfix_expression "[" expression "]"
    | postfix_expression DOT IDENTIFIER

init_declarator: declarator "=" initializer
    | declarator

// before it has been defined as such
enumeration_constant: IDENTIFIER

argument_expression_list: assignment_expression
    | argument_expression_list comma assignment_expression

comma: ","

primary_expression: IDENTIFIER
    | constant
    | string_constant
    | "(" expression ")" -> paren_expression

initializer: "{" initializer_list "}"
    | "{" initializer_list "," "}"
    | assignment_expression

?constant: I_CONSTANT        // includes character_constant
    | F_CONSTANT
    | boolean_value
    | NONE
    // | ENUMERATION_CONSTANT  // after it has been defined as such

NONE: "None"

boolean_value: boolean_true | boolean_false

boolean_true: TRUE
boolean_false: FALSE

TRUE: "True"
FALSE: "False"

string_constant: STRING | LONG_STRING

initializer_list: designation initializer
    | initializer
    | initializer_list "," designation initializer
    | initializer_list "," initializer

designation: designator_list "="

designator_list: designator
    | designator_list designator
    
designator: "[" constant_expression "]"
    | DOT IDENTIFIER

IDENTIFIER: ID
ENUMERATION_CONSTANT: ID

ID: /[a-zA-Z_][a-zA-Z_0-9]*/
DOT: "."

I_CONSTANT: /[1-9][0-9]*/ | "0"
F_CONSTANT: /[0-9]*"."[0-9]+/ | /[0-9]+"."/

LT_OP: "<"
GT_OP: ">"
LE_OP: "<="
GE_OP: ">="
EQ_OP: "=="
NE_OP: "!="
AND_OP: "&&"
OR_OP: "||"

ASSIGN: "="
MUL_ASSIGN: "*="
DIV_ASSIGN: "/="
MOD_ASSIGN: "%="
ADD_ASSIGN: "+="
SUB_ASSIGN: "-="

STATIC: "static"
CONST: "const"
ENUM: "enum"
ELLIPSIS: "..."

CASE: "case"
DEFAULT: "default"
IF: "if"
ELSE: "else"
SWITCH: "switch"
WHILE: "while"
DO: "do"
FOR: "for"
GOTO: "goto"
CONTINUE: "continue"
BREAK: "break"
RETURN: "return"

STRING: /"(?!"").*?(?<!\\)(\\\\)*?"/i
LONG_STRING: /""".*?(?<!\\)(\\\\)*?"""/is
REMAINING_LINE: /[^\n]+/

?comment: short_comment | long_comment
short_comment: SHORT_COMMENT _nl
long_comment: LONG_COMMENT
SHORT_COMMENT: /;[^\n]+/
LONG_COMMENT: /;;;.*?(?<!\\)(\\\\)*?;;;/is

%import common.NEWLINE
%import unicode.WS_INLINE

// %ignore NEWLINE
%ignore WS_INLINE
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT

