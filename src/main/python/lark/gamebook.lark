// game book

start: metadata sections

metadata: metadata_entry+
metadata_entry: metadata_tag ":" metadata_value? NEWLINE
metadata_tag: IDENTIFIER
metadata_value: REMAINING_LINE

sections: section statement+
section: "[" SECTION_NAME "]" NEWLINE

SECTION_NAME: /[^]]+/i

say_statement: say_string | say_long_string | say_expr
say_string.1: "say"? STRING
say_long_string.1: "say"? LONG_STRING
say_expr: "say" expression

direction_statement: DIRECTION STRING STRING? (FACING STRING)? NEWLINE

DIRECTION: "direction"
FACING: "facing"

option_statement: "option" STRING compound_statement
once_statement: "once" compound_statement // run once, first time run, further runs are a noop
library_statement: IDENTIFIER IDENTIFIER? expression NEWLINE

with_statement: "with" "world" compound_statement
            | "with" "section" compound_statement
            | "with" with_item compound_statement
with_item: IDENTIFIER ["as" IDENTIFIER]

// partial grammar taken from https://raw.githubusercontent.com/igordejanovic/parglare/master/examples/c/c2.pg

statement: section
    | labeled_statement
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | comment
    | direction_statement
    | once_statement
    | say_statement
    | with_statement
    | library_statement

labeled_statement: IDENTIFIER ":" statement
    | CASE constant_expression ":" statement
    | DEFAULT ":" statement

compound_statement: "{" "}"
    | "{"  block_item_list "}"

block_item_list: block_item
    | block_item_list block_item

block_item: declaration
    | statement

type_name: specifier_qualifier_list abstract_declarator
    | specifier_qualifier_list

abstract_declarator: pointer direct_abstract_declarator
    | pointer
    | direct_abstract_declarator

specifier_qualifier_list: type_specifier specifier_qualifier_list
    | type_specifier
    | type_qualifier specifier_qualifier_list
    | type_qualifier
    
direct_abstract_declarator: "(" abstract_declarator ")"
    | "[" "]"
    | "[" "*" "]"
    | "[" STATIC type_qualifier_list assignment_expression "]"
    | "[" STATIC assignment_expression "]"
    | "[" type_qualifier_list STATIC assignment_expression "]"
    | "[" type_qualifier_list assignment_expression "]"
    | "[" type_qualifier_list "]"
    | "[" assignment_expression "]"
    | direct_abstract_declarator "[" "]"
    | direct_abstract_declarator "[" "*" "]"
    | direct_abstract_declarator "[" STATIC type_qualifier_list assignment_expression "]"
    | direct_abstract_declarator "[" STATIC assignment_expression "]"
    | direct_abstract_declarator "[" type_qualifier_list assignment_expression "]"
    | direct_abstract_declarator "[" type_qualifier_list STATIC assignment_expression "]"
    | direct_abstract_declarator "[" type_qualifier_list "]"
    | direct_abstract_declarator "[" assignment_expression "]"
    | "(" ")"
    | "(" parameter_type_list ")"
    | direct_abstract_declarator "(" ")"
    | direct_abstract_declarator "(" parameter_type_list ")"

pointer: "*" type_qualifier_list pointer
    | "*" type_qualifier_list
    | "*" pointer
    | "*"

type_qualifier_list: type_qualifier
    | type_qualifier_list type_qualifier
    
parameter_type_list: parameter_list "," ELLIPSIS
    | parameter_list


parameter_list: parameter_declaration
    | parameter_list "," parameter_declaration


parameter_declaration: declaration_specifiers declarator
    | declaration_specifiers abstract_declarator
    | declaration_specifiers


identifier_list: IDENTIFIER
    | identifier_list "," IDENTIFIER


type_specifier: "var" | enum_specifier
type_qualifier: CONST

expression_statement: NEWLINE
    | expression NEWLINE

selection_statement: IF "(" expression ")" statement ELSE statement
    | IF "(" expression ")" statement
    | SWITCH "(" expression ")" statement

iteration_statement: WHILE "(" expression ")" statement
    | DO statement WHILE "(" expression ")" NEWLINE
    | FOR "(" expression_statement expression_statement ")" statement
    | FOR "(" expression_statement expression_statement expression ")" statement
    | FOR "(" declaration expression_statement ")" statement
    | FOR "(" declaration expression_statement expression ")" statement
    
jump_statement: GOTO IDENTIFIER NEWLINE
    | CONTINUE NEWLINE
    | BREAK NEWLINE
    | RETURN NEWLINE
    | RETURN expression NEWLINE

cast_expression: unary_expression
    | "(" type_name ")" cast_expression

multiplicative_expression: cast_expression
    | multiplicative_expression "*" cast_expression
    | multiplicative_expression "/" cast_expression
    | multiplicative_expression "%" cast_expression


additive_expression: multiplicative_expression
    | additive_expression "+" multiplicative_expression
    | additive_expression "-" multiplicative_expression


shift_expression: additive_expression
    | shift_expression LEFT_OP additive_expression
    | shift_expression RIGHT_OP additive_expression


relational_expression: shift_expression
    | relational_expression "<" shift_expression
    | relational_expression ">" shift_expression
    | relational_expression LE_OP shift_expression
    | relational_expression GE_OP shift_expression

equality_expression: relational_expression
    | equality_expression EQ_OP relational_expression
    | equality_expression NE_OP relational_expression


and_expression: equality_expression
    | and_expression "&" equality_expression


exclusive_or_expression: and_expression
    | exclusive_or_expression "^" and_expression


inclusive_or_expression: exclusive_or_expression
    | inclusive_or_expression "|" exclusive_or_expression


logical_and_expression: inclusive_or_expression
    | logical_and_expression AND_OP inclusive_or_expression


logical_or_expression: logical_and_expression
    | logical_or_expression OR_OP logical_and_expression

conditional_expression: logical_or_expression
    | logical_or_expression "?" expression ":" conditional_expression
    
assignment_expression: conditional_expression
    | unary_expression assignment_operator assignment_expression

assignment_operator: "="
    | MUL_ASSIGN
    | DIV_ASSIGN
    | MOD_ASSIGN
    | ADD_ASSIGN
    | SUB_ASSIGN
    | LEFT_ASSIGN
    | RIGHT_ASSIGN
    | AND_ASSIGN
    | XOR_ASSIGN
    | OR_ASSIGN

expression: assignment_expression
    | expression "," assignment_expression

constant_expression: conditional_expression    // with constraints

declaration: declaration_specifiers NEWLINE
    | declaration_specifiers init_declarator_list NEWLINE


declaration_specifiers: storage_class_specifier declaration_specifiers
    | storage_class_specifier
    | type_specifier declaration_specifiers
    | type_specifier
    | type_qualifier declaration_specifiers
    | type_qualifier

declarator: pointer direct_declarator
    | direct_declarator
    
enum_specifier: ENUM "{" enumerator_list "}"
    | ENUM "{" enumerator_list "," "}"
    | ENUM IDENTIFIER "{" enumerator_list "}"
    | ENUM IDENTIFIER "{" enumerator_list "," "}"
    | ENUM IDENTIFIER
    
unary_expression: postfix_expression
    | INC_OP unary_expression
    | DEC_OP unary_expression
    | unary_operator cast_expression

unary_operator: "&"
    | "*"
    | "+"
    | "-"
    | "~"
    | "!"

init_declarator_list: init_declarator
    | init_declarator_list "," init_declarator

storage_class_specifier: STATIC

direct_declarator: IDENTIFIER
    | "(" declarator ")"
    | direct_declarator "[" "]"
    | direct_declarator "(" parameter_type_list ")"
    | direct_declarator "(" ")"
    | direct_declarator "(" identifier_list ")"

enumerator_list: enumerator
    | enumerator_list "," enumerator


// identifiers must be flagged as ENUMERATION_CONSTANT
enumerator: enumeration_constant "=" constant_expression
    | enumeration_constant

postfix_expression: primary_expression
    | postfix_expression "[" expression "]"
    | postfix_expression "(" ")"
    | postfix_expression "(" argument_expression_list ")"
    | postfix_expression DOT IDENTIFIER
    | postfix_expression PTR_OP IDENTIFIER
    | postfix_expression INC_OP
    | postfix_expression DEC_OP
    
init_declarator: declarator "=" initializer
    | declarator

// before it has been defined as such
enumeration_constant: IDENTIFIER

argument_expression_list: assignment_expression
    | argument_expression_list "," assignment_expression
    
primary_expression: IDENTIFIER
    | constant
    | string
    | "(" expression ")"

initializer: "{" initializer_list "}"
    | "{" initializer_list "," "}"
    | assignment_expression

constant: I_CONSTANT        // includes character_constant
    | F_CONSTANT
    | ENUMERATION_CONSTANT  // after it has been defined as such

string: STRING | LONG_STRING

initializer_list: designation initializer
    | initializer
    | initializer_list "," designation initializer
    | initializer_list "," initializer

designation: designator_list "="

designator_list: designator
    | designator_list designator
    
designator: "[" constant_expression "]"
    | DOT IDENTIFIER

IDENTIFIER: ID
ENUMERATION_CONSTANT: ID

ID: /[a-zA-Z_][a-zA-Z_0-9]*/
DOT: "."

I_CONSTANT: /(0[xX])[a-fA-F0-9]+(((u|U)(l|L|ll|LL)?)|((l|L|ll|LL)(u|U)?))?/
    | /[1-9][0-9]*(((u|U)(l|L|ll|LL)?)|((l|L|ll|LL)(u|U)?))?/
    | /"0"[0-7]*(((u|U)(l|L|ll|LL)?)|((l|L|ll|LL)(u|U)?))?/

F_CONSTANT:/[0-9]+([Ee][+-]?[0-9]+)(f|F|l|L)?/
    | /[0-9]*"."[0-9]+([Ee][+-]?[0-9]+)?(f|F|l|L)?/
    | /[0-9]+"."([Ee][+-]?[0-9]+)?(f|F|l|L)?/
    | /(0[xX])[a-fA-F0-9]+([Pp][+-]?[0-9]+)(f|F|l|L)?/
    | /(0[xX])[a-fA-F0-9]*"."[a-fA-F0-9]+([Pp][+-]?[0-9]+)(f|F|l|L)?/
    | /(0[xX])[a-fA-F0-9]+"."([Pp][+-]?[0-9]+)(f|F|l|L)?/


PTR_OP: "->"
INC_OP: "++"
DEC_OP: "--"
LEFT_OP: "<<"
RIGHT_OP: ">>"
LE_OP: "<="
GE_OP: ">="
EQ_OP: "=="
NE_OP: "!="
AND_OP: "&&"
OR_OP: "||"

MUL_ASSIGN: "*="
DIV_ASSIGN: "/="
MOD_ASSIGN: "%="
ADD_ASSIGN: "+="
SUB_ASSIGN: "-="
LEFT_ASSIGN: "<<="
RIGHT_ASSIGN: ">>="
AND_ASSIGN: "&="
XOR_ASSIGN: "^="
OR_ASSIGN: "|="

STATIC: "static"
CONST: "const"
ENUM: "enum"
ELLIPSIS: "..."

CASE: "case"
DEFAULT: "default"
IF: "if"
ELSE: "else"
SWITCH: "switch"
WHILE: "while"
DO: "do"
FOR: "for"
GOTO: "goto"
CONTINUE: "continue"
BREAK: "break"
RETURN: "return"

STRING: /"(?!"").*?(?<!\\)(\\\\)*?"/i
LONG_STRING: /""".*?(?<!\\)(\\\\)*?"""/is
REMAINING_LINE: /[^\n]+/

comment: SHORT_COMMENT | LONG_COMMENT
SHORT_COMMENT: /;[^\n]+/ NEWLINE
LONG_COMMENT: /;;;.*?(?<!\\)(\\\\)*?;;;/is

%import common.NEWLINE
%import unicode.WS_INLINE

// %ignore NEWLINE
%ignore WS_INLINE
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT

